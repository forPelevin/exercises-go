---

name: Математика и числа
theory: |

  В Go представлено много числовых типов данных: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`, `complex64`, `complex128`. Суффиксы 8, 16, 32, 64 обозначают как много бит занимает тип данных.

  Выглядит устрашающе, не так ли? На самом деле вам не нужно запоминать все эти типы. В ежедневной работе вы будете сталкиваться с:
  - `int` — основной тип целых чисел, может быть отрицательным
  - `int64` нужен для больших чисел из внешних систем. Например, у вас ID в СУБД имеет тип `bigint`. Чтобы правильно распарсить такой ID, используется `int64`
  - `float64` — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max`, определяющая наибольшее число, принимает аргументы в виде `float64`

  В Go имеется стандартный набор арифметических операций:

  ```go
  x := 10
  y := 5

  // сложение
  x + y // 15

  // вычитание
  x - y // 5

  // деление
  x / y // 2

  // умножение
  x * y // 50
  ```

  При этом любые операции осуществляются только над числами одинакового типа:

  ```go
  x := 5.05
  y := 10

  x + y  // invalid operation: x + y (mismatched types float64 and int)
  ```

  Чтобы осуществить сложение из прошлого примера, нам нужно конвертировать значения к одному типу

  ```go
  x := 5.05
  y := 10

  x + float64(y)  // 15.05
  ```

  Числовые типы конвертируются без проблем между собой, однако есть нюансы, о которых стоит помнить:

  ```
  // нельзя конвертировать float64 к целому числу, если после точки не одни нули
  x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer

  x := int64(5.00) // OK

  // uint не может быть отрицательным
  x := uint(-5) // constant -5 overflows uint
  ```

  Приведенные выше примеры вызовут ошибки компиляции, поэтому вам не удастся "выстрелить себе в ногу". Однако существуют способы обмануть компилятор и тогда вы получите неявное поведение в коде:

  ```go
  a, _ := strconv.Atoi("-42")

  // ошибки компиляции нет, но число было преобразовано в положительное путем прибавления MAX_UINT+1. MAX_UINT = 18446744073709551615
  x := uint(a) // 18446744073709551574

  a, _ := strconv.Atoi("5.05")

  // ошибки компиляции так же нет, но значение всегда будет равно 0
  x := int(a) // 0
  ```

instructions: |

  В уроке упоминалась функция `math.Max`, которая сравнивает 2 числа и возвращает наибольшее. В этом задании следует использовать противоположную функцию `math.Min`, определяющую наименьшее число.
  Напишите функцию `MinInt()`, которая возвращает наименьшее целое число

tips:
  - |
    [The Go Programming Language Specification - Numeric Types](https://golang.org/ref/spec#Numeric_types)
