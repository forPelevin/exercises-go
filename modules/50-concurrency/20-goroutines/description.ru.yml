---

name: Горутины
theory: |

  Вот и подошло время познакомиться с самой сильной стороной языка Go — горутинами. Горутины — это легковесные потоки, которые реализуют конкурентное программирование в Go. Их называют *легковесными потоками*, потому что они управляются рантаймом языка, а не операционной системой. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.

  Запустить функцию в горутине — супер легко. Для этого достаточно написать слово `go` перед вызовом функции:

  ```go
  package main

  import (
  	"fmt"
  	"time"
  )

  func main() {
  	// выведет сообщение в горутине
  	go fmt.Println("Hello concurrent world")

  	// если не подождать, то программа закончится, не успев, вывести сообщение
  	time.Sleep(100 * time.Millisecond)
  }
  ```

  При написании конкурентного кода возникают новые моменты, которые нужно учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы, которая работает не так, как ожидается:

  ```go
  package main

  import (
  	"fmt"
  	"time"
  )

  func main() {
  	for i := 0; i < 5; i++ {
  		go func() {
  			fmt.Println(i)
  		}()
  	}

  	time.Sleep(100 * time.Millisecond)
  }
  ```

  Сперва может показаться, что должны вывестись числа от 0 до 4, но на самом деле вывод будет следующим:

  ```go
  5
  5
  5
  5
  5
  ```

  Все потому что *i* передается в общем скоупе, следовательно, когда горутины будут выполняться, цикл уже закончится и *i* будет равно *5*. В данном случае нужно передать копию *i*:

  ```go
  package main

  import (
  	"fmt"
  	"time"
  )

  func main() {
  	for i := 0; i < 5; i++ {
  		go func(i int) {
  			fmt.Println(i)
  		}(i)
  	}

  	time.Sleep(100 * time.Millisecond)
  }
  ```

  Вывод:

  ```go
  0
  4
  3
  1
  2
  ```

  Также можно заметить, что числа вывелись не в порядке вызова. Горутины выполняются независимо и не гарантируют порядка. При необходимости последовательность в выполнении придется реализовывать самостоятельно.

instructions: |

  Реализуйте функцию `MaxSum(nums1, nums2 []int) []int` из прошлого задания, используя горутины для расчета каждой суммы слайса.
  Не забудьте использовать функцию `time.Sleep(100 * time.Millisecond)`, чтобы сумма успела посчитаться. В настоящих приложениях используются специальные инструменты, чтобы дожидаться исполнения асинхронного кода, но для простоты здесь будет использоваться обычный сон.

tips:
  - |
    [Effective Go — Goroutines](https://golang.org/doc/effective_go#goroutines)
